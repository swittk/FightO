"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Proxy_1 = require("./Proxy");
var clone_1 = require("./clone");
var Timeline = (function () {
    function Timeline(maxSnapshots) {
        if (maxSnapshots === void 0) { maxSnapshots = 10; }
        this.startTime = null;
        this.lastSnapshotTime = -1;
        this.history = [];
        this.maxSnapshots = maxSnapshots;
    }
    Timeline.prototype.takeSnapshot = function (state, elapsedTime) {
        if (!this.startTime) {
            this.startTime = Date.now();
        }
        var now = (!elapsedTime) ? Date.now() : this.startTime + elapsedTime;
        var end = now - this.startTime;
        //
        // history timeframe:
        //
        // { "start": 0, "end": 1000, "data": {} }
        //
        this.history.push({
            start: this.lastSnapshotTime,
            end: end,
            data: clone_1.clone(state)
        });
        // drop older history
        if (this.history.length > this.maxSnapshots) {
            this.history.shift();
        }
        this.lastSnapshotTime = end;
    };
    /**
     * Get snapshot taken at `elapsedTime` interval.
     */
    Timeline.prototype.at = function (elapsedTimeAt, interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        var i = this.history.length;
        var lesserDistance = Infinity;
        var lesserDistanceIndex = 0;
        while (i--) {
            var frame_1 = this.history[i];
            var duration = ((frame_1.end - frame_1.start) / 2) - 1; // -1 is to prevent equal comparations
            var startDistance = Math.sqrt(Math.pow(elapsedTimeAt - frame_1.end - duration, 2));
            var endDistance = Math.sqrt(Math.pow(elapsedTimeAt - frame_1.end + duration, 2));
            if (startDistance < lesserDistance || endDistance < lesserDistance || elapsedTimeAt === frame_1.end) {
                lesserDistance = Math.min(startDistance, endDistance);
                lesserDistanceIndex = i;
            }
        }
        var frame = this.history[lesserDistanceIndex];
        var data = frame.data;
        //
        // traverse all properties to interpolate / extrapolate numbers
        //
        if (interpolate && elapsedTimeAt !== frame.end) {
            var previousState = this.at(frame.start, false);
            var multiplier = 1;
            if (elapsedTimeAt > frame.end) {
                //
                // extrapolation multiplier
                //
                // TODO: a better extrapolation method is needed.
                // needs to consider all previous states to evaluate a consistent next possible value
                //
                multiplier = -(elapsedTimeAt - frame.end) / (frame.end - frame.start);
            }
            else {
                multiplier = (elapsedTimeAt - frame.start) / (frame.end - frame.start);
            }
            return Proxy_1.createProxy(data, previousState, multiplier);
            //
            // It may be a good idea to traverse everything at once instead of
            // lazy-evaluating through proxies
            //
            // this.traverseInterpolate( data, // previousState, multiplier )
            //
        }
        return data;
    };
    Timeline.prototype.offset = function (offset, interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        return this.at(this.lastSnapshotTime + offset, interpolate);
    };
    return Timeline;
}());
exports.Timeline = Timeline;
