"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("../");
function notASetError(key) {
    throw new Error("'" + key + "' is not a Set.");
}
/*
 * SADD key member [member ...]
 * Add one or more members to a set
 */
function sadd(key, member, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("sadd", callback, key, member);
    }
    else {
        if (!(_1.store[key] instanceof Set)) {
            _1.store[key] = new Set();
        }
        _1.store[key].add(member);
        return true;
    }
}
exports.sadd = sadd;
/*
 * SCARD key
 * Get the number of members in a set
 */
function scard(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("scard", callback, key);
    }
    else {
        if (!(_1.store[key] instanceof Set)) {
            notASetError(key);
        }
        return _1.store[key].size;
    }
}
exports.scard = scard;
/*
 * SDIFF key [key ...]
 * Subtract multiple sets
 */
function sdiff() {
}
exports.sdiff = sdiff;
/*
 * SDIFFSTORE destination key [key ...]
 * Subtract multiple sets and store the resulting set in a key
 */
function sdiffstore() {
}
exports.sdiffstore = sdiffstore;
/*
 * SINTER key [key ...]
 * Intersect multiple sets
 */
function sinter() {
}
exports.sinter = sinter;
/*
 * SINTERSTORE destination key [key ...]
 * Intersect multiple sets and store the resulting set in a key
 */
function sinterstore() {
}
exports.sinterstore = sinterstore;
/*
 * SISMEMBER key member
 * Determine if a given value is a member of a set
 */
function sismember(key, member, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("sismember", callback, key, member);
    }
    else {
        if (!(_1.store[key] instanceof Set)) {
            notASetError(key);
        }
        return _1.store[key].has(member);
    }
}
exports.sismember = sismember;
/*
 * SMEMBERS key
 * Get all the members in a set
 */
function smembers(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("smembers", callback, key);
    }
    else {
        return (!(_1.store[key] instanceof Set))
            ? []
            : Array.from(_1.store[key].values());
    }
}
exports.smembers = smembers;
/*
 * SMOVE source destination member
 * Move a member from one set to another
 */
function smove() {
}
exports.smove = smove;
/*
 * SPOP key [count]
 * Remove and return one or multiple random members from a set
 */
function spop(key, count, callback) {
    if (count === void 0) { count = 1; }
    if (!_1.isMasterNode()) {
        _1.store.dispatch("spop", callback, key, count);
    }
    else {
        var members = srandmember(key, count, undefined);
        for (var i = 0, len = members.length; i < len; i++) {
            srem(key, members[i], undefined);
        }
        return members;
    }
}
exports.spop = spop;
/*
 * SRANDMEMBER key [count]
 * Get one or multiple random members from a set
 */
function srandmember(key, count, callback) {
    if (count === void 0) { count = 1; }
    if (!_1.isMasterNode()) {
        _1.store.dispatch("srandmember", callback, key, count);
    }
    else {
        var setLength = _1.store[key].size;
        var returnArr = [];
        var isPositive = true ? (count > 0) : false;
        count = Math.abs(count);
        var set = Array.from(_1.store[key]);
        if ((isPositive) && (count >= setLength)) {
            return set;
        }
        var returnedIndexes = [];
        for (var i = 0; i < count; i++) {
            var randIndex;
            do {
                randIndex = Math.floor(Math.random() * setLength);
            } while ((isPositive) && (returnedIndexes.indexOf(randIndex) != -1));
            returnArr.push(set[randIndex]);
            if (isPositive) {
                returnedIndexes.push(randIndex);
            }
        }
        return returnArr;
    }
}
exports.srandmember = srandmember;
/*
 * SREM key member [member ...]
 * Remove one or more members from a set
 */
function srem(key, member, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("srem", callback, key, member);
    }
    else {
        return (!(_1.store[key] instanceof Set))
            ? false
            : _1.store[key].delete(member);
    }
}
exports.srem = srem;
/*
 * SUNION key [key ...]
 * Add multiple sets
 */
function sunion() {
}
exports.sunion = sunion;
/*
 * SUNIONSTORE destination key [key ...]
 * Add multiple sets and store the resulting set in a key
 */
function sunionstore() {
}
exports.sunionstore = sunionstore;
/*
 * SSCAN key cursor [MATCH pattern] [COUNT count]
 * Incrementally iterate Set elements
 */
function sscan() {
}
exports.sscan = sscan;
