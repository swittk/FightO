"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("../");
function _ensureList(key) {
    if (!(key in _1.store)) {
        _1.store[key] = [];
    }
}
/*
 * BLPOP key [key ...] timeout
 * Remove and get the first element in a list, or block until one is available
 */
function blpop() {
}
exports.blpop = blpop;
/*
 * BRPOP key [key ...] timeout
 * Remove and get the last element in a list, or block until one is available
 */
function brpop() {
}
exports.brpop = brpop;
/*
 * BRPOPLPUSH source destination timeout
 * Pop a value from a list, push it to another list and return it; or block until one is available
 */
function brpoplpush() {
}
exports.brpoplpush = brpoplpush;
/*
 * LINDEX key index
 * Get an element from a list by its index
 */
function lindex(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("lindex", callback, key, value);
    }
    else {
        return (!_1.store[key])
            ? null
            : _1.store[key].indexOf(value);
    }
}
exports.lindex = lindex;
/*
 * LINSERT key BEFORE|AFTER pivot value
 * Insert an element before or after another element in a list
 */
function linsert() {
}
exports.linsert = linsert;
/*
 * LLEN key
 * Get the length of a list
 */
function llen(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("llen", callback, key);
    }
    else {
        return (_1.store[key] || []).length;
    }
}
exports.llen = llen;
/*
 * LPOP key
 * Remove and get the first element in a list
 */
function lpop(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("lpop", callback, key);
    }
    else {
        return (_1.store[key] || []).shift();
    }
}
exports.lpop = lpop;
/*
 * LPUSH key value [value ...]
 * Prepend one or multiple values to a list
 */
function lpush(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("lpush", callback, key, value);
    }
    else {
        _ensureList(key);
        return lpushx(key, value, undefined);
    }
}
exports.lpush = lpush;
/*
 * LPUSHX key value
 * Prepend a value to a list, only if the list exists
 */
function lpushx(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("lpushx", callback, key, value);
    }
    else {
        try {
            return _1.store[key].unshift(value);
        }
        catch (e) {
            if (!(key in _1.store)) {
                throw new Error("key does not exist");
            }
            throw new Error("key is not a list");
        }
        ;
    }
}
exports.lpushx = lpushx;
/*
 * LRANGE key start stop
 * Get a range of elements from a list
 */
function lrange(key, start, stop, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("lrange", callback, key, start, stop);
    }
    else {
        if (!(key in _1.store)) {
            return [];
        }
        var list = _1.store[key];
        if (stop === -1) {
            stop = list.length;
        }
        return list.slice(start, stop);
    }
}
exports.lrange = lrange;
/*
 * LREM key count value
 * Remove elements from a list
 */
function lrem() {
}
exports.lrem = lrem;
/*
 * LSET key index value
 * Set the value of an element in a list by its index
 */
function lset(key, index, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("lset", callback, key, index, value);
    }
    else {
        if (_1.store[key][index] === undefined) {
            throw new Error("index out of range");
        }
        _1.store[key][index] = value;
        return "OK";
    }
}
exports.lset = lset;
/*
 * LTRIM key start stop
 * Trim a list to the specified range
 */
function ltrim() {
}
exports.ltrim = ltrim;
/*
 * RPOP key
 * Remove and get the last element in a list
 */
function rpop(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("rpop", callback, key);
    }
    else {
        return (_1.store[key] || []).pop();
    }
}
exports.rpop = rpop;
/*
 * RPOPLPUSH source destination
 * Remove the last element in a list, prepend it to another list and return it
 */
function rpoplpush(source, destination, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("rpoplpush", callback, source, destination);
    }
    else {
        var value = rpop(source, undefined);
        lpush(destination, value, undefined);
        return value;
    }
}
exports.rpoplpush = rpoplpush;
/*
 * RPUSH key value [value ...]
 * Append one or multiple values to a list
 */
function rpush(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("rpush", callback, key, value);
    }
    else {
        _ensureList(key);
        return rpushx(key, value, undefined);
    }
}
exports.rpush = rpush;
/*
 * RPUSHX key value
 * Append a value to a list, only if the list exists
 */
function rpushx(key, value, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("rpushx", callback, key, value);
    }
    else {
        try {
            return _1.store[key].push(value);
        }
        catch (e) {
            if (!(key in _1.store)) {
                throw new Error("key does not exist");
            }
            throw new Error("key is not a list");
        }
        ;
    }
}
exports.rpushx = rpushx;
