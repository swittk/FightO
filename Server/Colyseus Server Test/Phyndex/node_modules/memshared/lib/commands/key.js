"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("../");
/**
 * DEL key [key ...]
 * Delete a key
 */
function del(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("del", callback, key);
    }
    else {
        delete _1.store[key];
        return "OK";
    }
}
exports.del = del;
/**
 * DUMP key
 * Return a serialized version of the value stored at the specified key.
 */
function dump() {
}
exports.dump = dump;
/**
 * EXISTS key [key ...]
 * Determine if a key exists
 */
function exists(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("exists", callback, key);
    }
    else {
        return (_1.store[key] !== undefined);
    }
}
exports.exists = exists;
/**
 * EXPIRE key seconds
 * Set a key's time to live in seconds
 */
function expire() {
}
exports.expire = expire;
/**
 * EXPIREAT key timestamp
 * Set the expiration for a key as a UNIX timestamp
 */
function expireat() {
}
exports.expireat = expireat;
/**
 * KEYS pattern
 * Find all keys matching the given pattern
 */
function keys(pattern, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("keys", callback, pattern);
    }
    else {
        var keys_1 = [];
        var regexp = new RegExp(pattern.replace("*", ".*"));
        var allKeys = Object.keys(_1.store);
        for (var i = 0, len = allKeys.length; i < len; i++) {
            if (regexp.test(allKeys[i])) {
                keys_1.push(allKeys[i]);
            }
        }
        return keys_1;
    }
}
exports.keys = keys;
/**
 * MIGRATE host port key|"" destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]
 * Atomically transfer a key from a Redis instance to another one.
 */
function migrate() {
}
exports.migrate = migrate;
/**
 * MOVE key db
 * Move a key to another database
 */
function move() {
}
exports.move = move;
/**
 * OBJECT subcommand [arguments [arguments ...]]
 * Inspect the internals of Redis objects
 */
function object() {
}
exports.object = object;
/**
 * PERSIST key
 * Remove the expiration from a key
 */
function persist() {
}
exports.persist = persist;
/**
 * PEXPIRE key milliseconds
 * Set a key's time to live in milliseconds
 */
function pexpire() {
}
exports.pexpire = pexpire;
/**
 * PEXPIREAT key milliseconds-timestamp
 * Set the expiration for a key as a UNIX timestamp specified in milliseconds
 */
function pexpireat() {
}
exports.pexpireat = pexpireat;
/**
 * PTTL key
 * Get the time to live for a key in milliseconds
 */
function pttl() {
}
exports.pttl = pttl;
/**
 * RANDOMKEY
 * Return a random key from the keyspace
 */
function randomkey() {
}
exports.randomkey = randomkey;
/**
 * RENAME key newkey
 * Rename a key
 */
function rename(key, newkey, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("rename", callback, key, newkey);
    }
    else {
        if (!_1.store[key]) {
            throw new Error("no such key '" + key + "'");
        }
        _1.store[newkey] = _1.store[key];
        delete _1.store[key];
        return true;
    }
}
exports.rename = rename;
/**
 * RENAMENX key newkey
 * Rename a key, only if the new key does not exist
 */
function renamenx() {
}
exports.renamenx = renamenx;
/**
 * RESTORE key ttl serialized-value [REPLACE]
 * Create a key using the provided serialized value, previously obtained using DUMP.
 */
function restore() {
}
exports.restore = restore;
/**
 * SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]
 * Sort the elements in a list, set or sorted set
 */
function sort() {
}
exports.sort = sort;
/**
 * TOUCH key [key ...]
 * Alters the last access time of a key(s). Returns the number of existing keys specified.
 */
function touch() {
}
exports.touch = touch;
/**
 * TTL key
 * Get the time to live for a key
 */
function ttl() {
}
exports.ttl = ttl;
/**
 * TYPE key
 * Determine the type stored at key
 */
function type(key, callback) {
    if (!_1.isMasterNode()) {
        _1.store.dispatch("type", callback, key);
    }
    else {
        var jsType = _1.store[key].constructor.name.toLowerCase();
        // Valid redis types are: 'string', 'list', 'set', 'zset', 'hash'
        if (jsType === "array") {
            jsType = "list";
        }
        else if (jsType === "object") {
            jsType = "hash";
        }
        return jsType;
    }
}
exports.type = type;
/**
 * UNLINK key [key ...]
 * Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.
 */
function unlink() {
}
exports.unlink = unlink;
/**
 * WAIT numslaves timeout
 * Wait for the synchronous replication of all the write commands sent in the context of the current connection
 */
function wait() {
}
exports.wait = wait;
/**
 * SCAN cursor [MATCH pattern] [COUNT count]
 * Incrementally iterate the keys space
 */
function scan() {
}
exports.scan = scan;
