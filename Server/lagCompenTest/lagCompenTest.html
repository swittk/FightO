<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Fast-Paced Multiplayer: Sample Code and Live Demo - Gabriel Gambetta</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="js/jquery-3.2.1.min.js"></script>
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-17633478-1', 'auto');
    ga('send', 'pageview');
  
  
    var __send_ga_event = function(spec, opt_url) {
      var parts = spec.split("-");
      var opt_callback = undefined;
      if (!!opt_url) {
        //console.log("URL " + opt_url);
        opt_callback = {
          'transport': 'beacon',
          'hitCallback': function(){ document.location = opt_url; }
        };
      }
      //console.log("Event " + spec);
      ga('send', 'event', parts[0], parts[1], parts[2], opt_callback);
      return false;
    }
  
    var __add_gg_handlers = function(data_attr, opt_href_prefix) {
      $("[" + data_attr + "]").each(function(_, link) {
        var spec = $(link).attr(data_attr);
        var handler = (function() { 
          var href = undefined;
          if (!!opt_href_prefix) {        
            href = opt_href_prefix + spec;
            if (!$(link).attr("href")) {
              $(link).attr("href", href);
            }
          } else if (!$(link).attr("href")) {
            $(link).attr("href", "#");
          }
          var save_spec = spec;
          return function() { return __send_ga_event(save_spec, href); };
        })()
        $(link).click(handler);
      });
    }
  
    var __add_event_tracking = function() {
      __add_gg_handlers("gg-event");
      __add_gg_handlers("gg-link", "outbound.php?link=");
    }
  
    $(__add_event_tracking);
  </script>
  <!-- End Google Analytics -->
</head>
<body>
<div class="main">
<div class="nav">
<a href="client-server-game-architecture.html"><< Series Start</a>	<a class="homelink" href="index.html">Gabriel Gambetta</a>
</div>
<header>
<h1 class="title">Fast-Paced Multiplayer: Sample Code and Live Demo</h1>
</header>
<p><a href="client-server-game-architecture.html">Client-Server Game Architecture</a> · <a href="client-side-prediction-server-reconciliation.html">Client-Side Prediction and Server Reconciliation</a> · <a href="entity-interpolation.html">Entity Interpolation</a> · <a href="lag-compensation.html">Lag Compensation</a> · <a href="client-side-prediction-live-demo.html">Live Demo</a></p>
<style>
canvas {
    border: dotted 1px;
    padding:0;
    background: lightgray;
}</style>
<p>This is a sample implementation of a client-server architecture demonstrating the main concepts explained in my <a href="client-server-game-architecture.html">Fast-Paced Multiplayer</a> series of articles. It won’t make much sense unless you’ve read the articles first.</p>
<p>The code is pure JavaScript and it’s fully contained in this page. It’s less than 500 lines of code, including a lot of comments, showing that once you really understand the concepts, implementing them is relatively straightforward.</p>
<p>Although it’s not production-quality code, you may use this code in your own applications. Credit is appreciated although not required.</p>
<div style="border: 5px solid blue; padding: 15px;">
<p><b>Player 1 view</b> - move with LEFT and RIGHT arrow keys<br> Lag = <input type="text" id="player1_lag" size=5 value="250" onchange="updateParameters();">ms</input> · <input type="checkbox" id="player1_prediction" onchange="updateParameters();">Prediction</input> · <input type="checkbox" id="player1_reconciliation" onchange="updateParameters();">Reconciliation</input> · <input type="checkbox" id="player1_interpolation" onchange="updateParameters();">Interpolation</input></p>
<canvas id="player1_canvas" width="920" height="75">
</canvas>
<div id="player1_status" style="font-family:courier;">
Waiting for connection…
</div>
</div>
<div style="height: 1em;">

</div>
<div style="border: 2px solid grey; padding: 15px;">
<p><b>Server view</b> · Update <input type="text" id="server_fps" size=5 value="3" onchange="updateParameters();"> times per second</input></p>
<canvas id="server_canvas" width="920" height="75">
</canvas>
<div id="server_status" style="font-family:courier;">

</div>
</div>
<div style="height: 1em;">

</div>
<div style="border: 5px solid red; padding: 15px;">
<p><b>Player 2 view</b> - move with A and D keys<br> Lag = <input type="text" id="player2_lag" size=5 value="150" onchange="updateParameters();">ms</input> · <input type="checkbox" id="player2_prediction" onchange="updateParameters();">Prediction</input> · <input type="checkbox" id="player2_reconciliation" onchange="updateParameters();">Reconciliation</input> · <input type="checkbox" id="player2_interpolation" onchange="updateParameters();">Interpolation</input></p>
<canvas id="player2_canvas" width="920" height="75">
</canvas>
<div id="player2_status" style="font-family:courier;">
Waiting for connection…
</div>
</div>
<script src="lagCompenTest.js"></script>
<h1 id="guided-tour">Guided Tour</h1>
<p>The views above show the state of the game world according to the server, and what two clients are rendering. You can move the blue ball, controlled by Player 1, with the LEFT and RIGHT arrow keys; and the red ball, controlled by Player 2, with the A and D keys.</p>
<p>Move the blue ball. There’s considerable delay between pressing the arrow keys and the blue ball actually moving. Without client-side prediction, the client only renders the new position of the ball only after a round-trip to the server. Because of the 250ms lag, this takes a while.</p>
<p>Set the <strong>player 1 Lag to 0ms</strong>, and try again. Now the client and the server move in sync because there’s no delay between them, but the movement isn’t smooth, because the server only updates its internal state 3 times per second. If you increase the <strong>update rate of the server to 60</strong>, we get smooth movement.</p>
<p>But this is not a very realistic scenario. Set the <strong>player 1 lag back to 250ms</strong>, and the <strong>server update rate back to 3</strong>. This is closer to the awful conditions where a real game still needs to work.</p>
<p>Client-side prediction and server reconciliation to the rescue! Enable both of them for Player 1 and move the blue ball. Now the movement is very smooth, and there’s no perceptible delay between pressing the arrow keys and moving the ball.</p>
<p>This still works if you make the conditions even worse - try setting the <strong>player 1 lag to 500ms</strong> and the <strong>server update rate to 1</strong>.</p>
<p>Now things look fantastic for player 1’s own entity, the blue ball. However, player 2’s view of this same entity looks terrible. Because the low update rate of the server, player 2 only gets a new position for player 1’s entity once per second, so the movement is very jumpy.</p>
<p>Enabling client-side prediction and server reconciliation for player 2 do nothing to smooth the movement of the blue ball, because these techniques only affect how a player renders its own entity. It does make a difference if you move the red ball, but now we have the same jumpiness in player 1’s view.</p>
<p>To solve this, we use entity interpolation. Enable <strong>entity interpolation for player 2</strong> and move the blue ball. Now it moves smoothly, but is always rendered “in the past” compared to player 1 and to the server.</p>
<p>You may notice the speed of the interpolated entities may vary. This is an artifact of the interpolation, caused by setting the server update rate too low in relationship with the speeds. This effect should disappear almost entirely if you set the <strong>server update rate to 10</strong>, which is still pretty low.</p>
<h1 id="summary">Summary</h1>
<p>Client-Side Prediction and Server Reconciliation are very powerful techniques to make multiplayer games feel responsive even under extremely bad network conditions. Therefore, they are a fundamental part of almost any client/server multiplayer network architecture.</p>
<div class="centered">
<a href="client-server-game-architecture.html">Series Start</a>
</div>
<div id="signup" class="signup signup_tgl">

</div>
<script>$("#signup").load("signup.php?m=gamedev&r=fpm_live");</script>
<hr>
<div class="social">

<!-- Facebook -->
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" style="width: 150px;"></div>


<!-- Google+ -->
<div class="g-plusone"></div>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>


<!-- Twitter -->
<a href="https://twitter.com/share" class="twitter-share-button" data-via="gabrielgambetta">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

</div>
</div>
<div class="copyright">&copy; Gabriel Gambetta 2017</div>
</body>
</html>
