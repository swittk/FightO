var counter = (function(){
    var i=0;
    return {
        get: function () {return i;},
        set: function (val) {i=val;},
        increment: function () {return ++i;}
    };
}());

var counter2 = {
    i: 0,
    get: function (){ return i;},
    set: function (val) {i = val;},
    increment: function (){ return i++ }
};
/*
var int1 = 456;
var int2 = 20;
var round = int2 * Math.round(int1/int2);
logOutput(int1/int2);
logOutput(Math.round(int1/int2));
logOutput(round);
*/
//for (const [key, value] of obj.entries(obj)) { }
/*
obj = {p: [4,5,6], v: [1,2,3], a: [7,8,9]};

Object.entries(obj).forEach(([key, value]) => {
    logOutput(key + " : ");
    for (var i=0;i<obj[key].length;i++)
        logOutput(obj[key][i]);
  });

*/

class LinkedList { // Timeline Doubly Linked List
    constructor () {
      this._head = null;
      this._tail = null;
      this._length = 0;
    }
    arrayHasOwnIndex(array, prop) {
      return array.hasOwnProperty(prop) && /^0$|^[1-9]\d*$/.test(prop) && prop <= 4294967294; // something for loop in array
    }
    nodeCreate (ts,val) {
        var temp = {};
        temp.ts = Number(ts); // to eliminate WTF events like javascript thinking that "ts" is string, so ("5" > "15") is "true" => wasted 6 hrs finding this bug.
        temp.data = val;
        temp.prev = null;
        temp.next = null;
        return temp;
    }
    findBound (ts) { // return maximum Node which (node.ts <= ts) // return null if no such node
      var iterator = this._head;
      while (iterator!==null) {
        if (ts < iterator.ts)
            return null; // as first node is (ts < iterator.ts), return null
        if (iterator.next===null)
          return iterator; // return this.tail -> maximum in this list, not yet (node.ts > ts)
        if (ts < iterator.next.ts)
          return iterator; // return the correct node since next node is (node.ts > ts)
        iterator = iterator.next;
      }
      return null; // no node avaliable, return null
    }
    addAtFront (ts, val) {
        var temp = this.nodeCreate(ts, val);
        if (this._head === null) { //This is first node
            this._head = temp;
            this._tail = temp;
        } else {
            if (this._head.ts==ts) {
                this._head.data = val;
                return;
            }
            temp.next = this._head;
            this._head.prev = temp;
            this._head = temp;
        }
        this._length++;
    }
    addAtBack (ts, val) {
        var temp = this.nodeCreate(ts, val);
        if (this._tail === null) { //This is first node
            this._tail = temp;
            this._head = temp;
        } else {
            if (this._tail.ts==ts) {
                this._tail.data = val;
                return;
            }
            temp.prev = this._tail;
            this._tail.next = temp;
            this._tail = temp;
        }
        this._length++;
    }
    removeAtFront () {
      var toReturn = null;
      if (this._head) {
        toReturn = this._head.data;
        if (this._tail===this._head) {
          this._head = null;
          this._tail = null;
        } else {
          this._head = this._head.next;
          this._head.prev = null;
        }
        this._length--;
      }
      return toReturn;
    }
    removeAtBack () {
      var toReturn = null;
      if (this._tail) {
        toReturn = this._tail.data;
        if (this._head===this._tail) {
          this._head = null;
          this._tail = null;
        } else {
          this._tail = this._tail.prev;
          this._tail.next = null;
        }
        this._length--;
      }
      return toReturn;
    }
    merge (node, val) {
      for (var key in val) {
        if (arrayHasOwnIndex(val, key)) {
            node[key] = {...node[key], ...val[key]};
        }
      }
    }
    addValue (ts,val) { // add new node at/just after ts
      var insert = this.findBound(ts);
      if (insert===null) 
          this.addAtFront(ts,val); // add new node at front
      else if (insert===this._tail)
          this.addAtBack(ts,val); // add new node at back
      else if (insert.ts===ts) {
          this.merge(insert, val); // found same ts => merge data
      } else {
          var temp = this.nodeCreate(ts, val);
          temp.prev = insert; // add new node inbetween
          temp.next = insert.next;
          temp.prev.next = temp;
          temp.next.prev = temp;
          this._length++;
      }
    }
    removeUntil (ts) { // remove unused node (until >= ts) for sake of freeing memory
        var target = this.findBound(ts);
        if (target===null)
            return; //mission complete
        if (target===this._head)
            return; //mission complete
        var iterator = target.prev;
        while (iterator!=this._head) {
            iterator = iterator.prev; // move to prev
            iterator.next.prev = null; // begin deconstruction at iterator.next node
            iterator.next.next = null;
            iterator.next.ts = null;
            iterator.next.data = null;
            iterator.next = null;
            this._length--;
        }
        this._head = target; // move head to target
        iterator.next = null; //begin deconstruction at iterator node
        iterator.ts = null;
        iterator.data = null;
        iterator.prev = null;
        iterator = null; // mission complete
        this._length--;
    }
    getValue (ts) { // get data (Object) that is ts maximally <=ts
        var find = this.findBound(ts);
        if (!find)
            return null;
        return find.data;
    }
    size () {
        return this._length;
    }
    printlist () {//test printing
        var iterator = this._head;
        var i=0;
        console.log(this._head)
        console.log(this._tail);
        console.log("LENGTH: " + this._length);
        while (iterator!==null) {
            console.log ("No." + (++i));
            console.log(iterator);
            if (iterator.next === null)
            break;
            iterator = iterator.next;
        }
    }
    parsestr () {
      var payload = {};
      if (this._head!==null) {
        var iterator = this._head;
        while (true) {
            payload[iterator.ts] = iterator.data;
            if (iterator===this._tail)
              break;
            iterator = iterator.next;
        };
      }
      return JSON.stringify(payload);
    }
    parsetimeline (str) {
      var payload = JSON.parse(str);
      this.removeUntil(4294967294);
      this.removeAtFront();
      for (var key in payload) {
        if (this.arrayHasOwnIndex(payload, key)) {
          this.addValue(key, payload[key]);
        }
      }
    }
  }
  
var link = new LinkedList();

function addname () {
    var name = document.getElementById("nameInput").value;
    var idx = Number(document.getElementById("numberInput").value);
    link.addValue(idx,name);
    link.printlist();
}

function removename () {
    var idx = Number(document.getElementById("numberInput").value);
    link.removeUntil (idx);
    link.printlist();
}

function parse () {
    logOutput(link.parsestr());
}

function getParse () {
    var input = document.getElementById("parseInput").value;
    link.parsetimeline(input);
    link.printlist();
}

    //                  each index [1,2,3,4] of
    //                    - each property {a:,p:,v:} of
    //                      - each value {x:,y:}
    /*
   function merge (host,obj) { 
    for(var i in obj) {
        for(var j in obj[i]) {
          host[i][j] = obj[i][j];
        }
      }
    }

  var host = [,
    {a:{x:1,y:2},
     p:undefined,
     v:{x:5,y:6}},
     {a:{x:13,y:14},
     p:undefined,
     v:{x:17,y:18}},
     {a:{x:19,y:20},
     p:undefined,
     v:{x:23,y:24}}
  ]
  console.log(host);

  var obj = [,
    {
     p:{x:3,y:4}}
     ,
     {
     p:{x:15,y:16}}
     ,
     {
     p:{x:21,y:22}
     }
  ]

  console.log(host);
  console.log(obj);
  merge(host,obj);
  console.log(host);
  console.log(obj);
*/
/*
var a = {
    a: {x:1,y:2},
    b: {x:3,y:4},
    c: {x:4,y:5}
  };
  
  var b = {c: {x:0,y:0}, d: {x:0,y:0}}
  b = {...a, ...b};

  console.log(b);*/
  // expected output: 3 5
  /*
  function set (rel_time, key, bodyidx, val) { // set Active Index
    var payload = [];
    if (key==undefined) {
      payload = bakeActiveIndex();
    } else {
      payload[bodyidx] = {[key]: val};
    }
    return payload;
  }

  var temp = set (1);
  console.log(temp);
*/

function logOutput(message) {
    var output = document.getElementById("messagedisplay");
    output.innerHTML = output.innerHTML + message + "<br>";
}

var myMap = new Map();
myMap.set(1,"hello");
myMap.set(2,"Yo");
console.log(myMap.get(1));
console.log(myMap.get(2));
console.log(myMap.get(3));
console.log(myMap);
console.log(myMap);
console.log(myMap.has(1));
console.log(myMap.has(3));
console.log(myMap[[3]]);
console.log(myMap.get(3));
console.log(myMap.has(1));
console.log(myMap.has(3));